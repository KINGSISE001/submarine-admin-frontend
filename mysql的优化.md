## mysql的优化

1. 首先我们要知道什么样的sql语句需要优化,查询慢的语句,但是还需要一个条件就是频繁使用的语句.

2. 如果一年半载才执行一次,公司没有必要去让专人去维护他.只要保证大多数人群的体验即可。

3. 第一步,查看我 们mysql的引擎是否是InnoDB

4. 然后做一个日志表(慢查询日志),把执行的慢的语句执行后查过,统一收集在日志表中

5. 或者使用 show processlist命令查看当前哪些正在执行sql的线程是休眠状态,是否锁表,对sql的执行进行观察

6. 通过往语句前面加**explain**分析sql语句,判断sql的性能情况(主要看type ,key(索引) ,rows)

7. 执行set profiling=1(开启profile)查看SQL语句暂用CPU的 时长

8. 通过show profile for query query_id 语句可以查看到该sql执行过程中每一个线程的状态和消耗时间

9. 执行时尽量用具体的字段作为返回的结果不要用*****,因为*****会做一个全部数据的转换
10. 查数据时尽量使用全值匹配,因为这样他会使用到索引,查询效率比较高
11. 查看sql语句的执行计划查看,是否有索引
12. 给执行语句慢的sql创建索引(create index idx**_**字段(条件)_自定义 on 表名(字段))

13. 在查询条件怎么**避免索引失效**,全值匹配时,首先不用模糊查询(like),对索引中所有的列都指定具体值

14. 在查询是要遵守最左前缀法则(什么是最左前缀法则呢,顾名思义就是从左到右的顺序,比如我们创建索引时是按照a,b,c的顺序创建的,然而我们只要违反了顺序,或者没有从第一个开始查,就会索引失效,explain分析的语句type就会是All全局扫描),避免索引失效

15. 而范围查询 (< ,>)右边的条件即使有索引也将失效.

16. 不要在索引列上进行运算操作,否则索引也将失效.

17. 字符串不加单引号,也会造成索引失效(对字符串没有加单引号,mysql查询优化器会进行类型转换,所造成的索引失效)
18. 尽量不要使用or 使用or会让索引失效而and不会
19.  以%开头的like模糊查询,索引会失效,但%在后面是不会失效的(通过覆盖索引来解决,就是把select*换成具体的字段)
20. 当你查找的字段在你所查的表中占但多数的时候,mysql会根据索引查和字段全局查询做一个判断评估,哪个快就用哪个方式来查询结果,这样有可能你的索引也用不到
21. 用is null 和is not null 有时索引也会失效
22. in 走索引 ,not in 索引会失效
23. 当我们使用索引时,尽量使用符合索引,而少使用单列索引

创建一个复合索引:

- create index  idx**_**字段1**_**字段2_字段3   on 表名 (字段1,字段2,字段3)
- 就相当于创建了3个索引
  - 字段1+字段2+字段3

当需要导入大批量数据时可以用mysql 的load命令去直接导入数据  ,导入的数据尽量有一些顺序

- 关闭唯一性校验
- 手动提交事务

**尽量用内连接代替子查询**

**在使用到on时尽量拿union去优化**

**索引失效(问题)**:

1、在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。
2、在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。
3、LIKE操作中，’%aaa%'不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。
4、在索引的列上使用表达式或者函数会使索引失效例如：select * from users where YEAR(adddate) < 2007，这将导致索引失效而进行全表扫描
5、在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。
6、字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败，应该改为WHERE email='99999'。
7、在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来。
8、如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。

**什么时候不要使用索引:**
1、经常增删改的列不要建立索引；
2、有大量重复的列不建立索引；
3、表记录太少不要建立索引。

